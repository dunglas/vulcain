%%%
title = "The Vulcain Protocol"
area = "Internet"
workgroup = "Network Working Group"

[seriesInfo]
name = "Internet-Draft"
value = "draft-dunglas-vulcain-01"
stream = "IETF"
status = "informational"

[[author]]
initials="K."
surname="Dunglas"
fullname="Kévin Dunglas"
abbrev = "Les-Tilleuls.coop"
organization = "Les-Tilleuls.coop"
  [author.address]
  email = "kevin@les-tilleuls.coop"
  [author.address.postal]
  city = "Lille"
  street = "2 rue Hegel"
  code = "59000"
  postalline= ["Bâtiment Canal"]
  country = "France"
%%%

.# Abstract

This specification defines new HTTP headers (and query parameters) allowing a client to inform the server of the exact data it needs:

* `Preload` informs the server that relations of the main requested resource will be necessary. The server can then reduce the number of round-trips by sending the related resources ahead of time using HTTP/2 [!@RFC7540] Server Push. When using Server Push isn't possible (resources served by a different authority, server not supporting HTTP/2...), the server can hint the client to fetch those resources as early as possible by using the `preload` link relation [@W3C.CR-preload-20190626] and the `103` status code [!@RFC8297].
* `Fields` informs the server of the list of fields of the retrieved resources that will be used. In order to improve performance and reduce bandwidth usage, the server can omit the not requested fields.

{mainmatter}

# Terminology

The keywords **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**, **SHOULD
NOT**, **RECOMMENDED**, **MAY**, and **OPTIONAL**, when they appear in this document, are to be
interpreted as described in [@!RFC2119].

# Preload Header

Many formats including HTML [@W3C.REC-html52-20171214], JSON-LD [@W3C.REC-json-ld-20140116], Atom [@RFC4287], XML [@W3C.REC-xml-20081126], [HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) and [JSON:API](https://jsonapi.org/) allow to use Web Linking [@!RFC5988] to represent references between resources.

The `Preload` HTTP header allows the client to ask the server to transmit resources linked to the main resource it will need as soon as possible. To do so, the `Preload` header `MUST` contain a selector (see #Selectors) referencing links to resources that `SHOULD` be preloaded.

The server `MUST` recursively follow links referenced by the selector. When a selector traverses several resources, all the traversed resources `SHOULD` be send to the client. If several links referencing the same resource are selected, this resource `MUST` be send at most one time.

The server `MAY` limit the number resources that it sends in response to one request.

Several selectors can be send by passing multiple `Preload` HTTP headers.

Considering the following resources:

`/books`

~~~ json
{
    "member": [
        "/books/1",
        "/books/2"
    ]
}
~~~

`/books/1`

~~~ json
{
    "title": "1984",
    "author": "/authors/1"
}
~~~

`/books/2`

~~~ json
{
    "title": "Homage to Catalonia",
    "author": "/authors/1"
}
~~~

`/authors/1`

~~~ json
{
    "givenName": "George",
    "familyName": "Orwell"
}
~~~

The `Preload` HTTP header can be used to ask the server to immediately push resources related to the requested one:

~~~ http
GET /books/ HTTP/2
Preload: /member/*/author
~~~

In addition to `/books`, the server `SHOULD` use HTTP/2 Server Push to push the `/books/1`, `/books/2` and `/authors/1` resources. While it is referenced two times, `/authors/1` `MUST` be pushed only one time.

Server Push requests generated by the server for related resources `MUST` include the remaining selector in a `Preload` HTTP header.
When requesting a pushed relation, the client `MUST` compute the remaining selector and pass it in the `Preload` header.

Example:

Explicit Request: 

~~~ http
GET /books/ HTTP/2
Preload: /member/*/author
~~~

Request to a relation generated by the server (for the push) and the client:

~~~ http
GET /books/1 HTTP/2
Preload: /author
~~~

## Using Preload Link Relations

If it's not possible or beneficial to use HTTP/2 Server Push (reference to a resource not served by the same authority, client or server not supporting HTTP/2, client having disabled Server Push...), `preload` link relations [@W3C.CR-preload-20190626] `SHOULD` be used as a fallback.

The server `MUST NOT` add `preload` link relations if the related resources are pushed using HTTP/2 Server Push.

# Fields Header

The `Fields` HTTP header allows the client to ask the server to return only the specified fields of the requested resource, and of the preloaded related resources.

The `Fields` HTTP header must contain a selector (see #Selector). The server `SHOULD` return only the fields matching this selector.

Multiple `Fields` HTTP headers can be passed. All fields matching at least one of these headers must be returned. Other fields of the resource `CAN` be omitted.

Considering the following resources:

`/books/1`

~~~ json
{
    "title": "1984",
    "genre": "novel",
    "author": "/authors/1"
}
~~~

`/authors/1`

~~~ json
{
    "givenName": "George",
    "familyName": "Orwell"
}
~~~

And the following HTTP request:

~~~ http
GET /books/1 HTTP/2
Preload: /author
Fields: /author/familyName
Fields: /genre
~~~

The server must return a response containing the following JSON document:

~~~ json
{
    "kind": "novel",
    "author": "/authors/1"
}
~~~

And push the following filtered `/authors/1` resource:

~~~ json
{
    "familyName": "Orwell"
}
~~~

Server Push requests generated by the server for related resources `MUST` include the remaining selector in a `Fields` HTTP header.
When requesting a pushed relation, the client `MUST` compute the remaining selector and pass it in the `Fields` header.

Example:

Explicit Request: 

~~~ http
GET /books/ HTTP/2
Fields: /member/*/author
~~~

Request to a relation generated by the server (for the push) and the client:

~~~ http
GET /books/1 HTTP/2
Fields: /author
~~~

# Selectors

Selectors used as value of the `Preload` and `Fields` HTTP headers depend of the Content-Type of the requested resource. This specification defines default selectors for common content-types, and a mechanism to use other selectors.

The client `SHOULD` use the `Accept` HTTP header to request the resource in a format compatible with selectors used in `Preload` and `Fields` HTTP headers.

The client can use the `Prefer` HTTP header [@!RFC7240] with the `selector` preference to ask the server to use a specific selector:

~~~ http
GET /books/1 HTTP/2
Accept: text/xml
Prefer: selector=css
Fields: brand > name
~~~

If no explicit preferences have been passed, the server `MUST` assume that the selector is the default one corresponding to the format of the resource.

The following table defines the default selector for common formats:

Format | Selector                                       | Identifier
-------|------------------------------------------------|-----------
JSON   | Extended JSON Pointer (#Extended-JSON-Pointer) | `json-pointer`
XML    | XPath [@W3C.REC-xpath-19991116]                | `xpath`
HTML   | CSS selectors [@W3C.REC-selectors-3-20181106]  | `css`

The client and the server can negotiate the use other selectors using the `Prefer` HTTP header.

## Extended JSON Pointer

For JSON documents, the default selector format is JSON Pointer [@!RFC6901]. However, JSON Pointer doesn't provide a mechanism to select entire collections.

This specification defines an extension to the JSON Pointer format allowing to select every element of a collection, the `*` character.

Considering the following JSON document:

~~~ json
{
    "books": [
        {
            "title": "1984",
            "author": "George Orwell"
        },
        {
            "title": "The Handmaid's Tale",
            "author": "Margaret Atwood"
        }
    ]
}
~~~

The `/books/*/author` JSON Pointer selects the `author` field of every objects in the `books` array.

The `*` character is escaped by encoding it as the `~2` character sequence.

By design, this selector is simple and limited. Simple selectors make it easier to limit the complexity of requests executed by the server.

# Query Parameters

Another option available to clients is to utilize Request URI query-string parameters to pass preload and fields selectors. The `preload` and `query` parameters `MAY` be used to pass selectors corresponding respectively to the `Preload` and `Fields` HTTP headers. To pass multiple selectors, parameters can be passed multiple times.

Example: `/books/1?fields=/title&fields=/author&preload=/author`

When using query parameters, the server `MUST` pass the remaining part of the selector as parameter of the generated link.

Example:

~~~ http
GET /books/?preload=/member/*/author HTTP/2

{
    "member": {
        "/books/1?preload=/author",
        "/books/1?preload=/author"
    }
}
~~~

As altering the URI can have undesirable effects, using HTTP headers `SHOULD` be preferred. Support for query parameters is `OPTIONAL`. A server supporting query parameters `MUST` also support the corresponding HTTP headers.

# Computing Links Server-Side

While using hypermedia capabilities of the HTTP protocol through Web Linking `SHOULD` always be preferred, sometimes links between resources are known by the server but are not provided in the HTTP response.

In such cases, the server can compute the link server-side in order to push the related resource.
Such server-side computed links `MAY` be documented, for instance by providing an [OpenAPI specification](https://www.openapis.org/) containing [Link objects](http://spec.openapis.org/oas/v3.0.2#link-object).

Considering the following resources and assuming that the server knows that the `author` field references the resources `/authors/{id}` resource:

`/books/1`

~~~ json
{
    "title": "1984",
    "author": 1
}
~~~

`/authors/1`

~~~ json
{
    "givenName": "George",
    "familyName": "Orwell"
}
~~~

In response to this request , both `/books/1` and `/authors/1` should be pushed:

~~~ http
GET /books/1 HTTP/2
Preload: /author
~~~

# Security Considerations

Using the `Preload` header can lead to a large number of resources to be generated and pushed. The server `SHOULD` limit the maximum number of resources to push. The depth of the selector `SHOULD` also be limited by the server.

# IANA considerations

The `Preload `and `Fields` header fields will be added to the "Permanent Message Header Field Names" registry defined in [@!RFC3864].

A selector registry could also be added.

{backmatter}
